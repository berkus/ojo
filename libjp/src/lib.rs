#![feature(nll)]

#[macro_use] extern crate serde_derive;

extern crate itertools;
extern crate sha2;
extern crate serde_yaml;

use sha2::{Sha256, Digest};
use std::collections::HashSet;
use std::ffi::OsString;
use std::fs::File;
use std::io;
use std::path::{Path, PathBuf};

mod error;
pub mod graph;

pub use error::Error;
pub use graph::Digle;

struct HashingWriter<W: io::Write> {
    writer: W,
    hasher: Sha256,
}

impl<W: io::Write> HashingWriter<W> {
    fn new(writer: W) -> HashingWriter<W> {
        HashingWriter {
            writer: writer,
            hasher: Default::default(),
        }
    }
}

impl<W: io::Write> io::Write for HashingWriter<W> {
    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
        self.hasher.input(buf);
        self.writer.write(buf)
    }

    fn flush(&mut self) -> io::Result<()> {
        self.writer.flush()
    }
}

#[derive(Clone, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct PatchId {
    data: [u8; 32],
}

impl PatchId {
    pub fn cur() -> PatchId {
        PatchId {
            data: [0; 32],
        }
    }

    pub fn is_cur(&self) -> bool {
        self.data == [0; 32]
    }
}

#[derive(Clone, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct LineId {
    patch: PatchId,
    line: u64,
}

impl LineId {
    fn set_patch_id(&mut self, id: &PatchId) {
        if self.patch.is_cur() {
            self.patch = id.clone();
        }
    }
}

#[derive(Clone, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub enum Change {
    NewNode {
        id: LineId,
        contents: Vec<u8>,
    },
    NewEdge {
        src: LineId,
        dst: LineId,
    },
}

impl Change {
    fn apply_to(&self, digle: &mut graph::Digle) {
        match *self {
            Change::NewNode { ref id, ref contents } =>
                digle.add_node(id, contents.clone()),
            Change::NewEdge { ref src, ref dst } => 
                digle.add_edge(src, dst),
        }
    }

    fn set_patch_id(&mut self, new_id: &PatchId) {
        match *self {
            Change::NewNode { ref mut id, .. } => {
                id.set_patch_id(new_id);
            },
            Change::NewEdge { ref mut src, ref mut dst } => {
                src.set_patch_id(new_id);
                dst.set_patch_id(new_id);
            }
        }
    }
}

/// A patch is ultimately identified by its id, which is generated by hashing the contents of the
/// serialized patch. This ends up being a bit circular, because the contents of the patch might
/// actually depend on the id, and those contents in turn will affect the id. The way we break this
/// cycle is by separating "unidentified" patches (those without an id yet) from completed patches
/// with an id.
///
/// This is an unidentified patch; it does not have an id field, and any changes in the `changes`
/// array that need to refer to this patch use the all-zeros placeholder as their patch id.
///
/// This patch *cannot* be applied to a repository, because doing so would require an id. However,
/// it can be serialized to a file, and it can be turned into an identified patch.
#[derive(Clone, Debug, Eq, Hash, PartialEq, Serialize)]
pub struct UnidentifiedPatch {
    pub header: PatchHeader,
    pub changes: Vec<Change>,
    pub deps: Vec<PatchId>,
}

impl UnidentifiedPatch {
    pub fn write_out<W: io::Write>(self, writer: W) -> Result<Patch, (UnidentifiedPatch, serde_yaml::Error)> {
        let mut w = HashingWriter::new(writer);
        if let Err(e) = serde_yaml::to_writer(&mut w, &self) {
                Err((self, e))
        } else {
            let id = w.hasher.result();
            let mut patch_id = PatchId::cur();
            patch_id.data.copy_from_slice(&id[..]);
            let mut ret = Patch {
                id: patch_id,
                header: self.header,
                changes: self.changes,
                deps: self.deps,
            };

            for change in &mut ret.changes {
                change.set_patch_id(&ret.id);
            }
            Ok(ret)
        }
    }
}

#[derive(Clone, Debug, Deserialize, Eq, Hash, PartialEq)]
pub struct Patch {
    pub id: PatchId,
    pub header: PatchHeader,
    pub changes: Vec<Change>,
    pub deps: Vec<PatchId>,
}

#[derive(Clone, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct PatchHeader {
    pub author: String,
    pub description: String,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Repo {
    /// The path to the database containing all the history, and so on.
    pub db_path: PathBuf,
    /// The path to the directory where patches are stored.
    pub patch_dir: PathBuf,
    /// The path to the file that is being tracked.
    pub file: PathBuf,
    digle: Digle,
    patches: HashSet<PatchId>,
}

impl Repo {
    fn db_path(file_path: &Path) -> Result<PathBuf, Error> {
        let parent = file_path.parent()
            .ok_or_else(|| Error::NoParent(file_path.to_path_buf()))?;
        let file_name = file_path.file_name()
            .ok_or_else(|| Error::NoFilename(file_path.to_path_buf()))?;

        let mut ret = parent.to_path_buf();
        let mut db_file_name = OsString::from("db_");
        db_file_name.push(file_name);
        ret.push(".jp");
        ret.push(db_file_name);
        Ok(ret)
    }

    fn patch_dir(file_path: &Path) -> Result<PathBuf, Error> {
        let parent = file_path.parent()
            .ok_or_else(|| Error::NoParent(file_path.to_path_buf()))?;

        let mut ret = parent.to_path_buf();
        ret.push(".jp");
        ret.push("patches");
        Ok(ret)
    }

    /// Opens the existing repo that is tracking the given file.
    pub fn open<P: AsRef<Path>>(path: P) -> Result<Repo, Error> {
        let db_path = Repo::db_path(path.as_ref())?;
        let patch_dir = Repo::patch_dir(path.as_ref())?;
        let db_file = File::open(&db_path)?;
        let db: Db = serde_yaml::from_reader(db_file)?;
        Ok(Repo {
            db_path,
            patch_dir,
            file: path.as_ref().to_path_buf(),
            digle: db.digle,
            patches: db.patches,
        })
    }

    /// Creates a repo for tracking the given file.
    pub fn init<P: AsRef<Path>>(path: P) -> Result<Repo, Error> {
        let db_path = Repo::db_path(path.as_ref())?;
        if db_path.exists() {
            return Err(Error::RepoExists(db_path));
        }
        let patch_dir = Repo::patch_dir(path.as_ref())?;

        Ok(Repo {
            db_path: db_path,
            patch_dir: patch_dir,
            file: path.as_ref().to_path_buf(),
            digle: Digle::new(),
            patches: HashSet::new(),
        })
    }

    pub fn digle(&self) -> Digle {
        self.digle.clone()
    }

    pub fn file(&self) -> Option<Vec<u8>> {
        unimplemented!();
    }
}

/// This struct, serialized, is the contents of the database.
#[derive(Debug, Deserialize, Serialize)]
struct Db {
    digle: Digle,
    patches: HashSet<PatchId>,
}

