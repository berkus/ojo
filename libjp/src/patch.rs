use chrono::{DateTime, Utc};
use serde_yaml;
use sha2::{Digest, Sha256};
use std::collections::HashSet;
use std::io::{self, prelude::*};

use crate::Error;
use crate::error::PatchIdError;

mod change;
pub use self::change::{Change, Changes};

// This is just a wrapper around some instance of io::Write that calculates a hash of everything
// that's written.
struct HashingWriter<W: Write> {
    writer: W,
    hasher: Sha256,
}

impl<W: Write> HashingWriter<W> {
    fn new(writer: W) -> HashingWriter<W> {
        HashingWriter {
            writer: writer,
            hasher: Default::default(),
        }
    }
}

impl<W: Write> Write for HashingWriter<W> {
    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
        self.hasher.input(buf);
        self.writer.write(buf)
    }

    fn flush(&mut self) -> io::Result<()> {
        self.writer.flush()
    }
}

/// A global identifier for a patch.
///
/// A `PatchId` is derived from a patch by hashing its contents. It must be unique: a repository
/// cannot simultaneously contain two patches with the same id.
#[derive(Copy, Clone, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
#[serde(transparent)]
pub struct PatchId {
    #[serde(with = "crate::Base64Slice")]
    pub(crate) data: [u8; 32],
}

impl PatchId {
    /// There is a special reserved `PatchId` for patches that are under construction, but not yet
    /// finished (see [`UnidentifiedPatch`] for more details). This function returns that special id.
    pub fn cur() -> PatchId {
        PatchId { data: [0; 32] }
    }

    /// Checks whether this `PatchId` is the one decribed in [`PatchId::cur`].
    pub fn is_cur(&self) -> bool {
        self.data == [0; 32]
    }

    /// Represents this `PatchId` in base64 (using the `URL_SAFE`) encoding.
    pub fn to_base64(&self) -> String {
        // We encode the filename in the URL_SAFE encoding because it needs to be a valid path
        // (e.g. no slashes).
        base64::encode_config(&self.data[..], base64::URL_SAFE)
    }

    /// Converts from base64 (in the `URL_SAFE`) encoding to a `PatchId`.
    pub fn from_base64<S: ?Sized + AsRef<[u8]>>(name: &S) -> Result<PatchId, PatchIdError> {
        let data = base64::decode_config(name, base64::URL_SAFE)?;
        let mut ret = PatchId::cur();
        if data.len() != ret.data.len() {
            Err(PatchIdError::InvalidLength(data.len()))
        } else {
            ret.data.copy_from_slice(&data);
            Ok(ret)
        }
    }
}

/// A patch is ultimately identified by its id, which is generated by hashing the contents of the
/// serialized patch. This ends up being a bit circular, because the contents of the patch might
/// actually depend on the id, and those contents in turn will affect the id. The way we break this
/// cycle is by separating "unidentified" patches (those without an id yet) from completed patches
/// with an id.
///
/// This is an unidentified patch; it does not have an id field, and any changes that need
/// to refer to contents of this patch use the placeholder id returned by [`PatchId::cur`].
///
/// This patch *cannot* be applied to a repository, because doing so would require an id. However,
/// it can be serialized to a file, and it can be turned into an identified patch.
#[derive(Clone, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct UnidentifiedPatch {
    changes: Changes,

    // Various metadata associated with this patch.
    //
    // Note that the metadata is hashed together will all the other contents of this patch. So,
    // for example, if you change the author of a patch then the resulting patch id will also
    // change.
    header: PatchHeader,

    // The list of other patches on which this depends. This should coincide with the set of all
    // other PatchIds that are referenced in `changes`.
    deps: Vec<PatchId>,
}

impl UnidentifiedPatch {
    /// Creates a new `UnidentifiedPatch` from some metadata and a set of changes.
    pub fn new(author: String, description: String, changes: Changes) -> UnidentifiedPatch {
        // The dependencies of this patch consist of all patches that are referred to by the list
        // of changes.
        let mut deps = HashSet::new();
        for c in &changes.changes {
            match *c {
                Change::DeleteNode { ref id } => {
                    if !id.patch.is_cur() {
                        deps.insert(id.patch.clone());
                    }
                }
                Change::NewEdge { ref src, ref dst } => {
                    if !src.patch.is_cur() {
                        deps.insert(src.patch.clone());
                    }
                    if !dst.patch.is_cur() {
                        deps.insert(dst.patch.clone());
                    }
                }
                _ => {}
            }
        }

        UnidentifiedPatch {
            header: PatchHeader {
                author,
                description,
                timestamp: Utc::now(),
            },
            changes,
            deps: deps.into_iter().collect(),
        }
    }

    // Assigns an id to this UnidentifiedPatch, and in doing so turns it into a Patch.
    fn set_id(self, id: PatchId) -> Patch {
        let mut ret = Patch {
            id,
            header: self.header,
            changes: self.changes,
            deps: self.deps,
        };

        ret.changes.set_patch_id(&ret.id);
        ret
    }

    /// Writes out a patch.
    ///
    /// While writing out the patch, we compute the hash of its contents and use that to derive an
    /// id for this patch. Assuming that the writing succeeds, we return the resulting [`Patch`].
    pub fn write_out<W: Write>(self, writer: W) -> Result<Patch, serde_yaml::Error> {
        let mut w = HashingWriter::new(writer);
        serde_yaml::to_writer(&mut w, &self)?;

        let id = w.hasher.result();
        let mut patch_id = PatchId::cur();
        patch_id.data.copy_from_slice(&id[..]);

        Ok(self.set_id(patch_id))
    }
}

#[derive(Clone, Debug, Deserialize, Eq, Hash, PartialEq)]
pub struct Patch {
    pub id: PatchId,
    pub header: PatchHeader,
    pub changes: Changes,
    pub deps: Vec<PatchId>,
}

impl Patch {
    pub fn from_reader<R: Read>(input: R, id: PatchId) -> Result<Patch, Error> {
        let up: UnidentifiedPatch = serde_yaml::from_reader(input)?;
        // TODO: should we verify that the id matches the hash of the input?
        Ok(up.set_id(id))
    }
}

#[derive(Clone, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct PatchHeader {
    /// Author of the patch.
    pub author: String,

    /// A description of the patch.
    pub description: String,

    /// The time at which the patch was created.
    pub timestamp: DateTime<Utc>,
}
