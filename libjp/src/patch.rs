use serde_yaml;
use sha2::{Digest, Sha256};
use std::io::{self, prelude::*};

use storage::{Digle, Storage};
use LineId;

// This is just a wrapper around some instance of io::Write that calculates a hash of everything
// that's written.
struct HashingWriter<W: Write> {
    writer: W,
    hasher: Sha256,
}

impl<W: Write> HashingWriter<W> {
    fn new(writer: W) -> HashingWriter<W> {
        HashingWriter {
            writer: writer,
            hasher: Default::default(),
        }
    }
}

impl<W: Write> Write for HashingWriter<W> {
    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
        self.hasher.input(buf);
        self.writer.write(buf)
    }

    fn flush(&mut self) -> io::Result<()> {
        self.writer.flush()
    }
}

#[derive(Clone, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct PatchId {
    data: [u8; 32],
}

impl PatchId {
    pub fn cur() -> PatchId {
        PatchId { data: [0; 32] }
    }

    pub fn is_cur(&self) -> bool {
        self.data == [0; 32]
    }
}

/// A patch is ultimately identified by its id, which is generated by hashing the contents of the
/// serialized patch. This ends up being a bit circular, because the contents of the patch might
/// actually depend on the id, and those contents in turn will affect the id. The way we break this
/// cycle is by separating "unidentified" patches (those without an id yet) from completed patches
/// with an id.
///
/// This is an unidentified patch; it does not have an id field, and any changes in the `changes`
/// array that need to refer to this patch use the all-zeros placeholder as their patch id.
///
/// This patch *cannot* be applied to a repository, because doing so would require an id. However,
/// it can be serialized to a file, and it can be turned into an identified patch.
#[derive(Clone, Debug, Eq, Hash, PartialEq, Serialize)]
pub struct UnidentifiedPatch {
    pub header: PatchHeader,
    pub changes: Vec<Change>,
    pub deps: Vec<PatchId>,
}

impl UnidentifiedPatch {
    pub fn write_out<W: Write>(
        self,
        writer: W,
    ) -> Result<Patch, (UnidentifiedPatch, serde_yaml::Error)> {
        let mut w = HashingWriter::new(writer);
        if let Err(e) = serde_yaml::to_writer(&mut w, &self) {
            Err((self, e))
        } else {
            let id = w.hasher.result();
            let mut patch_id = PatchId::cur();
            patch_id.data.copy_from_slice(&id[..]);
            let mut ret = Patch {
                id: patch_id,
                header: self.header,
                changes: self.changes,
                deps: self.deps,
            };

            for change in &mut ret.changes {
                change.set_patch_id(&ret.id);
            }
            Ok(ret)
        }
    }
}

#[derive(Clone, Debug, Deserialize, Eq, Hash, PartialEq)]
pub struct Patch {
    pub id: PatchId,
    pub header: PatchHeader,
    pub changes: Vec<Change>,
    pub deps: Vec<PatchId>,
}

impl Patch {
    pub fn store_contents(&self, storage: &mut Storage) {
        unimplemented!();
    }

    pub fn apply_to_digle(&self, digle: Digle) -> Digle {
        unimplemented!();
    }
}

#[derive(Clone, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct PatchHeader {
    pub author: String,
    pub description: String,
}

#[derive(Clone, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub enum Change {
    NewNode { id: LineId, contents: Vec<u8> },
    NewEdge { src: LineId, dst: LineId },
}

impl Change {
    fn apply_to_digle(&self, digle: Digle) -> Digle {
        match *self {
            Change::NewNode {
                ref id,
                ref contents,
            } => digle.add_node(id.clone()),
            Change::NewEdge { ref src, ref dst } => digle.add_edge(src.clone(), dst.clone()),
        }
    }

    fn store_new_contents(&self, storage: &mut Storage) {
        if let Change::NewNode {
            ref id,
            ref contents,
        } = *self
        {
            storage.add_contents(id.clone(), contents.to_owned());
        }
    }

    fn set_patch_id(&mut self, new_id: &PatchId) {
        match *self {
            Change::NewNode { ref mut id, .. } => {
                id.set_patch_id(new_id);
            }
            Change::NewEdge {
                ref mut src,
                ref mut dst,
            } => {
                src.set_patch_id(new_id);
                dst.set_patch_id(new_id);
            }
        }
    }
}
